import fs from 'fs-extra';
import chunk from 'lodash.chunk';
import tasks from './config/tasks';
import { INPUT_DIRECTORY, OUTPUT_DIRECTORY, RECORDS_CHUNK_SIZE } from './config/env';

class Translation {
  constructor(lang, title, query) {
    this.lang = lang;
    this.title = title;
    this.query = query;
  }

  static parse(json) {
    const title = `${json.title}_translation_${json.lang}`;
    const query = json.query(json.lang);
    return new Translation(json.lang, title, query);
  }

  get inputFile() {
    return `${INPUT_DIRECTORY}/${this.title}.json`;
  }
}

class Task {
  constructor(title, query, mapper) {
    this.title = title;
    this.query = query;
    this.mapper = mapper || function() { return ''; };
    this.scopes = [];
    this.translations = [];
  }

  async logError(fieldName, fieldValue, recordId){
    const outputFile = `${OUTPUT_DIRECTORY}/${this.title}-errors.txt`;
    let er = `Cannot map ${fieldName} value '${fieldValue}' for record ${recordId}` +'\n';
    await fs.appendFile(outputFile, er);
  }

  static parse(json) {
    const { title, query, mapper, translations } = json;
    const task = new Task(title, query, mapper);
    if (translations) {
      translations.languages.forEach((lang) => {
        const translation = Translation.parse({
          lang,
          title,
          query: translations.query
        });
        task.translations.push(translation);
      });
    }
    return task;
  }

  get inputFile() {
    return `${INPUT_DIRECTORY}/${this.title}.json`;
  }

  outputFile(scope) {
    return `${OUTPUT_DIRECTORY}/${this.title}-${scope}.ttl`;
  }

  async load(queryEngine) {
    await queryEngine(this.query, this.inputFile);
    if (this.translations.length) {
      for (const translation of this.translations) {
        await queryEngine(translation.query, translation.inputFile);
      }
    }
    console.log(`Finished loading records of ${this.title}`);
  }

  async parseInputFile() {
    const input = await fs.readFile(this.inputFile, 'utf8');
    const records = JSON.parse(input);
    const translations = await Promise.all(
      this.translations.map(async (translation) => {
        const translationInput = await fs.readFile(translation.inputFile, 'utf8');
        const translationRecords = JSON.parse(translationInput);
        return { lang: translation.lang, records: translationRecords };
      })
    );

    return { records, translations };
  }

  async execute() {
    console.log(`Executing task: ${this.title}`);

    // Parse input files
    const { records, translations } = await this.parseInputFile();

    // Map records in batches
    const graphCounts = {};
    const batches = chunk(records, RECORDS_CHUNK_SIZE);
    console.log(`Split task into ${batches.length} chunks of ${RECORDS_CHUNK_SIZE} records`);

    let i = 0;
    for (const batch of batches) {
      i++;
      const graphs = this.mapper(batch, translations, (fn,fv,ri) => this.logError(fn, fv, ri));
      this.scopes = Object.keys(graphs);
      for (const scope of this.scopes) {
        const graph = graphs[scope];
        const outputFile = this.outputFile(scope);
        if (i == 1) { // First iteration, cleanup possible dirty state from previous run
          await fs.remove(outputFile);
        }
        await fs.appendFile(outputFile, graph.toNT(), 'utf8');

        if (!graphCounts[scope]) {
          graphCounts[scope] = 0;
        }
        graphCounts[scope] += graph.length;
      }

      console.log(`Mapped ${Math.min(i * RECORDS_CHUNK_SIZE, records.length)}/${records.length} records`);
    }

    console.log('\n');
    console.log(`Number of statements per scope generated by task ${this.title}`);
    for (let scope in graphCounts) {
      console.log(`- [${scope}] ${graphCounts[scope]} statements`);
    }
    console.log('\n');

    return {
      title: this.title,
      source: this.inputFile,
      count: records.length
    };
  }
}

class RecordTask {
  constructor(parent, recordId) {
    this.parentTask = parent;
    this.recordId = recordId;
  }

  outputFile(scope, id) {
    return `${OUTPUT_DIRECTORY}/${this.parentTask.title}-${scope}-${id}.ttl`;
  }

  async execute() {
    // Parse input files
    const { records, translations } = await this.parentTask.parseInputFile();

    const record = records.find((record) => record['business_product_id'] == this.recordId);
    if (record) {
      console.log(`Executing task: ${this.parentTask.title} for record with ID '${this.recordId}'`);
      const outputFiles = [];
      const graphs = this.parentTask.mapper([record], translations, (fn,fv,ri) => this.parentTask.logError(fn, fv, ri));
      const scopes = Object.keys(graphs);
      for (const scope of scopes) {
        const graph = graphs[scope];
        const outputFile = this.outputFile(scope, this.recordId);
        await fs.remove(outputFile); // Cleanup possible dirty state from previous run
        await fs.appendFile(outputFile, graph.toNT(), 'utf8');
        outputFiles.push(outputFile);
      }

      console.log('Output is written to:');
      outputFiles.forEach((file) => console.log(`- ${file}`));
    } else {
      console.log(`Cannot find record with ID '${this.recordId}' in ${this.parentTask.title}`);
    }
  }
}

function loadTasksFromConfig() {
  return tasks
    .filter((task) => task.enabled)
    .map((task) => Task.parse(task));
}

export {
  loadTasksFromConfig,
  RecordTask
}
